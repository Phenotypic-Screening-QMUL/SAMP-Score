print(rf_confusion_mtx_test)
# Calculate precision, recall, F1-score, specificity, FPR
precision_test <- rf_confusion_mtx_test$byClass["Pos Pred Value"]
recall_test <- rf_confusion_mtx_test$byClass["Sensitivity"]
f1_score_test <- rf_confusion_mtx_test$byClass["F1"]
specificity_test <- rf_confusion_mtx_test$byClass["Neg Pred Value"]
fpr_test <- 1 - specificity_test
# Compute ROC curve and AUC
roc_curve_test <- roc(combined_testData$Senescence_Status, rf_probabilities_test)
auc_roc_test <- auc(roc_curve_test)
# Ensure the 'ROCs' directory exists
if (!dir.exists("ROCs")) {
dir.create("ROCs")
}
# Create the ROC plot
roc_plot <- ggroc(roc_curve_test, legacy.axes = TRUE, alpha = 0.5, colour = "blue", linetype = 1, size = 1) +
labs(title = "ROC Curve for Random Forest", x = "False Positive Rate", y = "True Positive Rate") +
geom_segment(aes(x = 0, xend = 1, y = 0, yend = 1), color = "black", linetype = "dashed")
# Save the ROC plot
ggsave("ROCs/roc_curve_rf.png", plot = roc_plot, width = 8, height = 6)
# Store metrics and confusion matrix breakdown for combined_testData in a data frame
rf_metrics_df_test <- data.frame(
Model = "Random Forest (Combined Test Data)",
Accuracy = rf_confusion_mtx_test$overall["Accuracy"],
Precision = precision_test,
Recall = recall_test,
F1_Score = f1_score_test,
AUC = auc_roc_test,
Neg_Pred_Value = specificity_test,
TP = rf_confusion_mtx_test$table["Sen", "Sen"],
TN = rf_confusion_mtx_test$table["NonSen", "NonSen"],
FN = rf_confusion_mtx_test$table["NonSen", "Sen"],
FP = rf_confusion_mtx_test$table["Sen", "NonSen"]
)
# Save the metrics for combined_testData to a CSV file
write.csv(rf_metrics_df_test, "rf_model_metrics.csv", row.names = FALSE)
# Plot variable importance
var_importance <- importance(rf_model)
var_importance_df <- data.frame(Variable = rownames(var_importance), Importance = var_importance[, "MeanDecreaseGini"])
var_importance_df <- var_importance_df[order(var_importance_df$Importance, decreasing = TRUE), ]
var_importance_plot <- ggplot(var_importance_df, aes(x = reorder(Variable, Importance), y = Importance)) +
geom_bar(stat = "identity", fill = "skyblue") +
coord_flip() +
labs(title = "Variable Importance for Random Forest", x = "Variable", y = "Importance")
# Save the variable importance plot
ggsave("ROCs/variable_importance_rf.png", plot = var_importance_plot, width = 8, height = 6)
# Create the meta-model testing data frame
rf_meta_model_data_testing <- data.frame(
rf_Prob = as.vector(rf_probabilities_test),
Senescence_Status = combined_testData$Senescence_Status,
Predicted_Status = rf_predictions_test
)
# Save the meta-model testing data for further use
write.csv(rf_meta_model_data_testing, "rf_meta_model_data_testing.csv", row.names = FALSE)
set.seed(123)
# Load required libraries
library(e1071)
library(caret)
library(pROC)
library(ggplot2)
# Ensure Senescence_Status is a factor (for classification)
trainData_part1$Senescence_Status <- as.factor(trainData_part1$Senescence_Status)
trainData_part2$Senescence_Status <- as.factor(trainData_part2$Senescence_Status)
combined_testData$Senescence_Status <- as.factor(combined_testData$Senescence_Status)
# Prepare training and test data for SVM
x_train <- trainData_part1[, -which(names(trainData_part1) == "Senescence_Status")]
y_train <- trainData_part1$Senescence_Status
x_test <- combined_testData[, -which(names(combined_testData) == "Senescence_Status")]
y_test <- combined_testData$Senescence_Status
# Fit the SVM model on trainData_part1
svm_model <- svm(x_train, y_train, kernel = "radial", probability = TRUE)
# Ensure trainData_part2 and combined_testData have the same features as x_train
x_train_part2 <- trainData_part2[, colnames(x_train), drop = FALSE]
# Make predictions on trainData_part2 using the SVM model
svm_predictions_part2 <- predict(svm_model, newdata = x_train_part2, probability = TRUE)
svm_probabilities_part2 <- attr(svm_predictions_part2, "probabilities")[, "Sen"]
svm_predicted_classes_part2 <- ifelse(svm_probabilities_part2 > 0.5, "Sen", "NonSen")
# Create the meta-model training data frame
svm_meta_model_data_training <- data.frame(
svm_Prob = as.vector(svm_probabilities_part2),
Senescence_Status = as.factor(trainData_part2$Senescence_Status),
Predicted_Status = svm_predicted_classes_part2
)
# Save the meta-model training data for further use
write.csv(svm_meta_model_data_training, "svm_meta_model_data_training.csv", row.names = FALSE)
## Now we are going to apply the model to testing data and evaluate
# Make predictions on combined_testData using the SVM model
x_test_combined <- combined_testData[, colnames(x_train), drop = FALSE]  # Ensure same columns as x_train
svm_predictions_test <- predict(svm_model, newdata = x_test_combined, probability = TRUE)
svm_probabilities_test <- attr(svm_predictions_test, "probabilities")[, "Sen"]
svm_predicted_classes_test <- ifelse(svm_probabilities_test > 0.5, "Sen", "NonSen")
# Create the meta-model testing data frame
svm_meta_model_data_testing <- data.frame(
svm_Prob = as.vector(svm_probabilities_test),
Senescence_Status = y_test,
Predicted_Status = svm_predicted_classes_test
)
# Save the meta-model testing data for further use
write.csv(svm_meta_model_data_testing, "svm_meta_model_data_testing.csv", row.names = FALSE)
# Convert predicted_classes and actual classes to factors
combined_testData$predicted_classes <- factor(svm_predicted_classes_test, levels = c("NonSen", "Sen"))
combined_testData$Senescence_Status <- factor(combined_testData$Senescence_Status)
# Create the confusion matrix for SVM on combined_testData
svm_confusion_mtx_test <- confusionMatrix(data = combined_testData$predicted_classes, reference = combined_testData$Senescence_Status)
print(svm_confusion_mtx_test)
# Calculate precision, recall, F1-score, specificity, FPR
precision_test <- svm_confusion_mtx_test$byClass["Pos Pred Value"]
recall_test <- svm_confusion_mtx_test$byClass["Sensitivity"]
f1_score_test <- svm_confusion_mtx_test$byClass["F1"]
specificity_test <- svm_confusion_mtx_test$byClass["Neg Pred Value"]
fpr_test <- 1 - specificity_test
# Compute ROC curve and AUC for SVM
roc_curve_test <- roc(combined_testData$Senescence_Status, svm_probabilities_test)
auc_roc_test <- auc(roc_curve_test)
# Calculate Cohen's Kappa
kappa_test <- svm_confusion_mtx_test$overall["Kappa"]
# Ensure the 'ROCs' directory exists
if (!dir.exists("ROCs")) {
dir.create("ROCs")
}
# Create the ROC plot for SVM
roc_plot <- ggroc(roc_curve_test, legacy.axes = TRUE, alpha = 0.5, colour = "blue", linetype = 1, size = 1) +
labs(title = "ROC Curve on Combined Test Data (SVM)", x = "False Positive Rate", y = "True Positive Rate") +
geom_segment(aes(x = 0, xend = 1, y = 0, yend = 1), color = "black", linetype = "dashed")
# Save the ROC plot
ggsave("ROCs/roc_curve_svm.png", plot = roc_plot, width = 8, height = 6)
# Store metrics and confusion matrix breakdown for combined_testData in a data frame
SVM_metrics_df_test <- data.frame(
Model = "SVM Model",
Accuracy = svm_confusion_mtx_test$overall["Accuracy"],
Precision = precision_test,
Recall = recall_test,
F1_Score = f1_score_test,
AUC = auc_roc_test,
Neg_Pred_Value = specificity_test,
Kappa = kappa_test,
TP = svm_confusion_mtx_test$table["Sen", "Sen"],
TN = svm_confusion_mtx_test$table["NonSen", "NonSen"],
FN = svm_confusion_mtx_test$table["NonSen", "Sen"],
FP = svm_confusion_mtx_test$table["Sen", "NonSen"]
)
# Save the metrics for combined_testData to a CSV file
write.csv(SVM_metrics_df_test, "svm_model_metrics.csv", row.names = FALSE)
set.seed(123)
# Load required libraries
library(mda)
library(caret)
library(pROC)
library(ggplot2)
# Ensure Senescence_Status is a factor (for classification)
trainData_part1$Senescence_Status <- as.factor(trainData_part1$Senescence_Status)
trainData_part2$Senescence_Status <- as.factor(trainData_part2$Senescence_Status)
combined_testData$Senescence_Status <- as.factor(combined_testData$Senescence_Status)
# Prepare training data for MDA
x_train_part2 <- trainData_part2[, -which(names(trainData_part2) == "Senescence_Status")]
y_train_part2 <- trainData_part2$Senescence_Status
# Fit the MDA model on trainData_part2
mda_model <- mda(Senescence_Status ~ ., data = trainData_part2)
# Ensure test data has the same features as x_train_part2
x_test_combined <- combined_testData[, colnames(x_train_part2), drop = FALSE]
# Make predictions on trainData_part2 using the MDA model
predicted_probabilities_train_mda <- predict(mda_model, newdata = trainData_part2, type = "posterior")
predicted_classes_train_mda <- ifelse(predicted_probabilities_train_mda[, "Sen"] > 0.5, "Sen", "NonSen")
# Create and save the meta-model data frame for trainData_part2
mda_meta_model_training <- data.frame(
mda_Prob = as.vector(predicted_probabilities_train_mda[, "Sen"]),
Senescence_Status = as.factor(trainData_part2$Senescence_Status),
Predicted_Status = predicted_classes_train_mda
)
write.csv(mda_meta_model_training, "mda_meta_model_training.csv", row.names = FALSE)
## Now we are going to apply the model to combined_testData and evaluate
# Make predictions on combined_testData using the MDA model
predicted_probabilities_test_mda <- predict(mda_model, newdata = combined_testData, type = "posterior")
predicted_classes_test_mda <- ifelse(predicted_probabilities_test_mda[, "Sen"] > 0.5, "Sen", "NonSen")
# Create and save the meta-model data frame for combined_testData
mda_meta_model_testing <- data.frame(
mda_Prob = as.vector(predicted_probabilities_test_mda[, "Sen"]),
Senescence_Status = as.factor(combined_testData$Senescence_Status),
Predicted_Status = predicted_classes_test_mda
)
write.csv(mda_meta_model_testing, "mda_meta_model_testing.csv", row.names = FALSE)
# Calculate accuracy for MDA on combined_testData
accuracy_test_mda <- mean(predicted_classes_test_mda == combined_testData$Senescence_Status)
print(paste("MDA Accuracy on combined_testData:", accuracy_test_mda))
# Assign predicted classes to combined_testData
combined_testData_pred <- combined_testData
combined_testData_pred$predicted_classes <- predicted_classes_test_mda
# Convert predicted_classes and actual classes to factors
combined_testData_pred$predicted_classes <- factor(predicted_classes_test_mda, levels = c("NonSen", "Sen"))
combined_testData_pred$Senescence_Status <- factor(combined_testData_pred$Senescence_Status)
# Create confusion matrix for MDA on combined_testData
mda_confusion_mtx_test <- confusionMatrix(data = combined_testData_pred$predicted_classes, reference = combined_testData_pred$Senescence_Status)
print(mda_confusion_mtx_test)
# Calculate precision, recall, F1-score, specificity, FPR
precision_test <- mda_confusion_mtx_test$byClass["Pos Pred Value"]
recall_test <- mda_confusion_mtx_test$byClass["Sensitivity"]
f1_score_test <- mda_confusion_mtx_test$byClass["F1"]
specificity_test <- mda_confusion_mtx_test$byClass["Neg Pred Value"]
fpr_test <- 1 - specificity_test
# Compute ROC curve and AUC for MDA on combined_testData
roc_curve_mda_test <- roc(combined_testData_pred$Senescence_Status, predicted_probabilities_test_mda[, "Sen"])
auc_roc_mda_test <- auc(roc_curve_mda_test)
# Calculate Cohen's Kappa
kappa_test <- mda_confusion_mtx_test$overall["Kappa"]
# Ensure the 'ROCs' directory exists
if (!dir.exists("ROCs")) {
dir.create("ROCs")
}
# Create the ROC plot for MDA on combined_testData
roc_plot_mda <- ggroc(roc_curve_mda_test, legacy.axes = TRUE, alpha = 0.5, colour = "blue", linetype = 1, size = 1) +
labs(title = "ROC Curve on Combined Test Data (MDA)", x = "False Positive Rate", y = "True Positive Rate") +
geom_segment(aes(x = 0, xend = 1, y = 0, yend = 1), color = "black", linetype = "dashed")
# Save the ROC plot
ggsave("ROCs/roc_curve_mda.png", plot = roc_plot_mda, width = 8, height = 6)
# Store metrics and confusion matrix breakdown for combined_testData in a data frame
mda_metrics_df_test <- data.frame(
Model = "MDA Model",
Accuracy = accuracy_test_mda,
Precision = precision_test,
Recall = recall_test,
F1_Score = f1_score_test,
AUC = auc_roc_mda_test,
Neg_Pred_Value = specificity_test,
Kappa = kappa_test,
TP = mda_confusion_mtx_test$table["Sen", "Sen"],
TN = mda_confusion_mtx_test$table["NonSen", "NonSen"],
FN = mda_confusion_mtx_test$table["NonSen", "Sen"],
FP = mda_confusion_mtx_test$table["Sen", "NonSen"]
)
# Save the metrics for combined_testData to a CSV file
write.csv(mda_metrics_df_test, "mda_model_metrics.csv", row.names = FALSE)
set.seed(123)
# Load required libraries
library(neuralnet)
library(caret)
library(pROC)
library(ggplot2)
# Prepare the data
Test_Train <- trainData_part1
Test_Test <- trainData_part2
Combined_Test <- combined_testData
# Convert Senescence_Status variable to binary {0, 1}
Test_Train$Senescence_Status <- ifelse(Test_Train$Senescence_Status == "Sen", 1, 0)
Test_Test$Senescence_Status <- ifelse(Test_Test$Senescence_Status == "Sen", 1, 0)
Combined_Test$Senescence_Status <- ifelse(Combined_Test$Senescence_Status == "Sen", 1, 0)
# Define formula for the neural network
formula <- as.formula("Senescence_Status ~ .")
# Train the neural network using trainData_part1
nn_model <- neuralnet(
formula,
data = Test_Train,
hidden = c(20,10,5,2),  # Define the number of neurons in hidden layers
linear.output = FALSE  # Use sigmoid activation function for binary classification
)
# Prepare meta-model training data
x_train_part2 <- Test_Test[, colnames(Test_Train), drop = FALSE]
# Make predictions on Test_Test using the NN model
predicted_probabilities_part2 <- compute(nn_model, as.matrix(x_train_part2[, -which(names(x_train_part2) == "Senescence_Status")]))$net.result
predicted_classes_part2 <- ifelse(predicted_probabilities_part2 > 0.5, 1, 0)
# Create and save the meta-model data frame for Test_Test
nn_meta_model_data_train <- data.frame(
nn_Prob = as.vector(predicted_probabilities_part2),
Senescence_Status = as.factor(Test_Test$Senescence_Status),
Predicted_Status = factor(predicted_classes_part2, levels = c(0, 1), labels = c("NonSen", "Sen"))
)
write.csv(nn_meta_model_data_train, "nn_meta_model_training.csv", row.names = FALSE)
## Now we are going to apply the model to Combined_Test and evaluate
# Make predictions on Combined_Test using the NN model
x_test_combined <- Combined_Test[, colnames(Test_Train), drop = FALSE]
predicted_probabilities_test <- compute(nn_model, as.matrix(x_test_combined[, -which(names(x_test_combined) == "Senescence_Status")]))$net.result
predicted_classes_test <- ifelse(predicted_probabilities_test > 0.5, 1, 0)
# Create and save the meta-model data frame for Combined_Test
nn_meta_model_data_test <- data.frame(
nn_Prob = as.vector(predicted_probabilities_test),
Senescence_Status = as.factor(Combined_Test$Senescence_Status),
Predicted_Status = factor(predicted_classes_test, levels = c(0, 1), labels = c("NonSen", "Sen"))
)
write.csv(nn_meta_model_data_test, "nn_meta_model_testing.csv", row.names = FALSE)
# Convert predicted_classes and actual classes to factors
Combined_Test$predicted_classes <- factor(predicted_classes_test, levels = c(0, 1), labels = c("NonSen", "Sen"))
Combined_Test$Senescence_Status <- factor(Combined_Test$Senescence_Status, levels = c(0, 1), labels = c("NonSen", "Sen"))
# Create confusion matrix for NN on Combined_Test
nn_confusion_mtx_test <- confusionMatrix(data = Combined_Test$predicted_classes, reference = Combined_Test$Senescence_Status)
print(nn_confusion_mtx_test)
# Calculate precision, recall, F1-score, specificity, FPR
precision_nn <- nn_confusion_mtx_test$byClass["Pos Pred Value"]
recall_nn <- nn_confusion_mtx_test$byClass["Sensitivity"]
f1_score_nn <- nn_confusion_mtx_test$byClass["F1"]
specificity_nn <- nn_confusion_mtx_test$byClass["Neg Pred Value"]
fpr_nn <- 1 - specificity_nn
# Compute ROC curve and AUC for NN
roc_curve_nn <- roc(Combined_Test$Senescence_Status, predicted_probabilities_test)
auc_roc_nn <- auc(roc_curve_nn)
# Calculate Cohen's Kappa
kappa_nn <- nn_confusion_mtx_test$overall["Kappa"]
# Ensure the 'ROCs' directory exists
if (!dir.exists("ROCs")) {
dir.create("ROCs")
}
# Create the ROC plot for NN
roc_plot_nn <- ggroc(roc_curve_nn, legacy.axes = TRUE, alpha = 0.5, colour = "blue", linetype = 1, size = 1) +
labs(title = "ROC Curve on Combined Test Data (Neural Network)", x = "False Positive Rate", y = "True Positive Rate") +
geom_segment(aes(x = 0, xend = 1, y = 0, yend = 1), color = "black", linetype = "dashed")
# Save the ROC plot
ggsave("ROCs/roc_curve_nn.png", plot = roc_plot_nn, width = 8, height = 6)
# Store metrics and confusion matrix breakdown for Combined_Test in a data frame
NN_metrics_df_test <- data.frame(
Model = "Neural Network",
Accuracy = nn_confusion_mtx_test$overall["Accuracy"],
Precision = precision_nn,
Recall = recall_nn,
F1_Score = f1_score_nn,
AUC = auc_roc_nn,
Neg_Pred_Value = specificity_nn,
FPR = fpr_nn,
Kappa = kappa_nn,
TP = nn_confusion_mtx_test$table["Sen", "Sen"],
TN = nn_confusion_mtx_test$table["NonSen", "NonSen"],
FN = nn_confusion_mtx_test$table["NonSen", "Sen"],
FP = nn_confusion_mtx_test$table["Sen", "NonSen"]
)
# Save the metrics for Combined_Test to a CSV file
write.csv(NN_metrics_df_test, "neural_network_metrics.csv", row.names = FALSE)
# Custom plot function for neural network
custom_plot_nn <- function(nn_model, plot_title = "Neural Network") {
plot(nn_model, rep = "best",
show.weights = TRUE,
dimension = c(2000, 800),
radius = 3,  # Adjust the radius of the nodes
fontsize = 18,  # Adjust the font size
arrow.length = 0.1,  # Adjust the length of the arrows
information = FALSE,
main = plot_title)
}
# Plot and save the neural network with custom function
plot_name <- "ROCs/neural_network_plot.png"
png(plot_name, width = 2000, height = 1000)
custom_plot_nn(nn_model)
dev.off()
set.seed(123)
# Load required libraries
library(glmnet)
library(caret)
library(pROC)
library(ggplot2)
# Combine model predictions and response variable for training
meta_model_data_train <- as.data.frame(cbind(
lasso_meta_model_data_training[,1],
svm_meta_model_data_training[,1],
en_meta_model_data_training[,1],
rf_meta_model_data_training[,1],
mda_meta_model_training[,1],
logistic_meta_model_data_training[,1],
nn_meta_model_data_train[,1:2]
))
colnames(meta_model_data_train) <- c("lasso", "svm", "en", "rf", "mda", "logistic", "nn", "Senescence_Status")
# Extract the predictors and response for training
train_predictors <- meta_model_data_train[, -ncol(meta_model_data_train)]
train_response <- as.factor(meta_model_data_train$Senescence_Status)
# Fit the Lasso model on the training meta-model data
lasso_model <- cv.glmnet(
x = as.matrix(train_predictors),
y = as.numeric(train_response) - 1,  # glmnet requires response to be zero-indexed
family = "binomial",
alpha = 1
)
# Get the best lambda
best_lambda <- lasso_model$lambda.min
# Combine model predictions and response variable for testing
meta_model_data_test <- as.data.frame(cbind(
lasso_meta_model_data_testing[,1],
svm_meta_model_data_testing[,1],
en_meta_model_data_testing[,1],
rf_meta_model_data_testing[,1],
mda_meta_model_testing[,1],
logistic_meta_model_data_testing[,1],
nn_meta_model_data_test[,1:2]
))
colnames(meta_model_data_test) <- c("lasso", "svm", "en", "rf", "mda", "logistic", "nn", "Senescence_Status")
# Extract the predictors and response for testing
test_predictors <- meta_model_data_test[, -ncol(meta_model_data_test)]
test_response <- as.factor(meta_model_data_test$Senescence_Status)
# Make predictions on the meta-model test data using the trained Lasso model
predicted_probabilities_test <- predict(lasso_model, newx = as.matrix(test_predictors), s = best_lambda, type = "response")
predicted_classes_test <- ifelse(predicted_probabilities_test > 0.50, "1", "0")
Lasso_accuracy_test <- mean(predicted_classes_test == meta_model_data_test$Senescence_Status)
print(paste("Lasso Accuracy on test data:", Lasso_accuracy_test))
# Prepare the data for confusion matrix
meta_model_data_test$predicted_classes <- factor(predicted_classes_test, levels = c("0", "1"))
# Convert actual classes to factor
meta_model_data_test$Senescence_Status <- factor(meta_model_data_test$Senescence_Status, levels = c("0", "1"))
# Create the confusion matrix for the test data
confusion_mtx_test <- confusionMatrix(data = meta_model_data_test$predicted_classes, reference = meta_model_data_test$Senescence_Status)
print(confusion_mtx_test)
# Calculate additional metrics for the test data
precision_test <- confusion_mtx_test$byClass["Pos Pred Value"]
recall_test <- confusion_mtx_test$byClass["Sensitivity"]
f1_score_test <- confusion_mtx_test$byClass["F1"]
specificity_test <- confusion_mtx_test$byClass["Neg Pred Value"]
fpr_test <- 1 - specificity_test
# Compute ROC curve and AUC for the test data
roc_curve_test <- roc(meta_model_data_test$Senescence_Status, as.numeric(predicted_probabilities_test))
auc_roc_test <- auc(roc_curve_test)
# Calculate Cohen's Kappa for the test data
kappa_test <- confusion_mtx_test$overall["Kappa"]
# Create the ROC plot for the test data
roc_plot_test <- ggroc(roc_curve_test, legacy.axes = TRUE, alpha = 0.5, colour = "blue", linetype = 1, size = 1) +
labs(title = "ROC Curve on Test Data (Meta Model)", x = "False Positive Rate", y = "True Positive Rate") +
geom_segment(aes(x = 0, xend = 1, y = 0, yend = 1), color = "black", linetype = "dashed")
# Save the ROC plot for the test data
ggsave("roc_curve_meta_model_test.png", plot = roc_plot_test, width = 8, height = 6)
# Store metrics and confusion matrix breakdown for the test data in a data frame
Meta_metrics_df_test <- data.frame(
Model = "Meta Model",
Accuracy = Lasso_accuracy_test,
Precision = precision_test,
Recall = recall_test,
F1_Score = f1_score_test,
AUC = auc_roc_test,
Neg_Pred_Value = specificity_test,
FPR = fpr_test,
Kappa = kappa_test,
TP = confusion_mtx_test$table["1", "1"],
TN = confusion_mtx_test$table["0", "0"],
FN = confusion_mtx_test$table["0", "1"],
FP = confusion_mtx_test$table["1", "0"]
)
# Save the metrics for the test data to a CSV file
write.csv(Meta_metrics_df_test, "Meta_Model_metrics_test.csv", row.names = FALSE)
# Get the list of CSV files in the working directory
csv_files <- list.files(pattern = "\\.csv$")
# Loop through each CSV file and read it into a data frame
for (file in csv_files) {
# Extract the name of the data frame from the file name
df_name <- sub(".csv$", "", file)
# Read the CSV file into a data frame
assign(df_name, read.csv(file))
}
# Define the desired columns
desired_columns <- c("Model", "Accuracy", "Precision", "Recall", "F1_Score", "AUC", "Neg_Pred_Value", "TP", "TN", "FN", "FP")
# Function to subset data frames to include only desired columns
subset_columns <- function(df, columns) {
# Check if all desired columns are present in the data frame
if (all(columns %in% colnames(df))) {
return(df[, columns, drop = FALSE])
} else {
# Return a message if some columns are missing
warning("Some columns are missing in the data frame")
return(df) # Return the original data frame if columns are missing
}
}
# Subset each data frame to keep only the desired columns
logistic_model_metrics <- subset_columns(logistic_model_metrics, desired_columns)
lasso_model_metrics <- subset_columns(lasso_model_metrics, desired_columns)
svm_model_metrics <- subset_columns(svm_model_metrics, desired_columns)
en_model_metrics <- subset_columns(en_model_metrics, desired_columns)
rf_model_metrics <- subset_columns(rf_model_metrics, desired_columns)
mda_model_metrics <- subset_columns(mda_model_metrics, desired_columns)
neural_network_metrics <- subset_columns(neural_network_metrics, desired_columns)
Meta_Model_metrics <- subset_columns(Meta_Model_metrics_test, desired_columns)
# Combine the subsetted data frames into one data frame
All_Metric <- rbind(
logistic_model_metrics,
lasso_model_metrics,
svm_model_metrics,
en_model_metrics,
rf_model_metrics,
mda_model_metrics,
neural_network_metrics,
Meta_Model_metrics
)
write.csv(All_Metric, "All_Model_Metrics.csv", row.names = FALSE)
# Define a folder to save the heatmaps
output_folder <- "Heatmaps"
if (!dir.exists(output_folder)) {
dir.create(output_folder)
}
# Function to save heatmap to file
save_heatmap <- function(matrix_data, file_name, cellnote_data) {
# Define the file path
file_path <- file.path(output_folder, file_name)
# Open a graphics device to save the plot
png(file_path, width = 800, height = 600)
# Plot heatmap
heatmap.2(matrix_data, Rowv = NA, Colv = NA, dendrogram = "none", trace = "none",
col = rev(colorRampPalette(c("red","white", "turquoise"))(256)), scale = "column", key = TRUE, keysize = 1.5,
key.title = NA, density.info = "none", cexRow = 0.8, cexCol = 0.8,
margins = c(8, 8), cellnote = cellnote_data, notecol = "black")
# Close the graphics device
dev.off()
}
# First Heatmap - Metrics in Percentages
HM_Met <- All_Metric[, -c(1,8:11)]
rownames(HM_Met) <- All_Metric[, 1]
rownames(HM_Met) <- gsub(" \\(Combined Test Data\\)", "", rownames(HM_Met))
HM_Met <- as.matrix(HM_Met)
HM_Met_percent <- HM_Met * 100
HM_Met_percent_rounded <- round(HM_Met_percent, 1)
HM_Met_percent_char <- matrix(paste0(HM_Met_percent_rounded, "%"), nrow = nrow(HM_Met_percent_rounded))
# Save the first heatmap
save_heatmap(HM_Met, "Heatmap_Metrics_Percentages.png", HM_Met_percent_char)
# Second Heatmap - Confusion Matrix Metrics
HM_Met <- All_Metric[, -c(1:7)]
rownames(HM_Met) <- All_Metric[, 1]
rownames(HM_Met) <- gsub(" \\(Combined Test Data\\)", "", rownames(HM_Met))
HM_Met <- as.matrix(HM_Met)
HM_Met <- round(HM_Met, 1)
# Save the second heatmap
save_heatmap(HM_Met, "Heatmap_Confusion_Matrix_Metrics.png", HM_Met)
onfusion_mtx_test
confusion_mtx_test
all<- read.csv("All_Data_Clusters_Consensus.csv")
